import type { ValueOfA, Primitives, Primitive, UnknownRecord, Constructor } from "./ts.js";
interface Expect {
    any<C>(constructor: C extends Constructor ? C : any): C extends Constructor ? Primitive<C> : C;
    arrayContaining<T = unknown>(expected: Array<T>): T[];
    objectContaining<T = unknown>(expected: T): T;
    stringMatching<T extends string>(expected: T): T;
}
interface ExpectGeneric extends Expect {
    (actual: unknown, message?: string): any;
    extend(matchers: unknown): void;
}
export declare type Matchers = {
    typeOrNull: <T extends Primitives>(matcher: T) => Primitive<T> | null;
    typeOrUndefined: <T extends Primitives>(matcher: T) => Primitive<T> | undefined;
    objectContainingOrEmpty: <T>(matcher: T) => T | UnknownRecord;
    objectContainingOrUndefined: <T>(matcher: T) => T | undefined;
    objectContainingOrNull: <T>(matcher: T) => T | null;
    objectContainingOrEmptyOrNullish: <T>(matcher: T) => T | UnknownRecord | undefined | null;
    keylessObjectContaining: <T>(matcher: T) => Record<string, T>;
    arrayContainingOrEmpty: <T>(matcher: [T]) => T[] | [];
    arrayContainingOrEmptyOrUndefined: <T>(matcher: [T]) => T[] | [] | undefined;
    enum: <T extends readonly unknown[]>(matcher: T) => ValueOfA<T>;
};
export declare type EExpect<T> = Expect & Matchers & T;
export declare const getExpect: <T extends ExpectGeneric>(expect: T) => EExpect<T>;
export {};
//# sourceMappingURL=test.d.ts.map