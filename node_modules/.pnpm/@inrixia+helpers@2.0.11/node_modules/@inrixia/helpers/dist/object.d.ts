import { UnknownRecord } from "./ts.js";
export declare const isDuplicate: (key: unknown) => boolean;
/**
 * Simple object check.
 * @param item
 * @returns {boolean}
 */
export declare const isObject: (item: unknown) => item is UnknownRecord;
/**
 * Deep merge objects into target. Without modifying target.
 * @param target
 * @param source
 */
export declare const deepMerge: <T extends S, S extends UnknownRecord = Partial<T>>(target: T, source: S) => T & S;
export declare type Types = {
    [key: string]: string | string[] | Types | Types[];
};
export declare type TypeCompareResult = boolean | {
    expectedType: string;
    received: string;
    location: string;
};
/**
 * Take in a target `object` and a `types` object with identical keys but values as array of types those keys should be.
 * @param target Object
 * @param types Object identical to `target` but values are types
 * @returns `object` if the types dont match. `True` if they do.
 */
export declare const deepTypeCompare: (target: UnknownRecord, types: Types, location?: string) => TypeCompareResult;
/**
 * Helper function for `deepTypeCompare` to compare a item to a type or set of types.
 * @param expectedTypes Expected type/types
 * @param receivedValue Object given
 * @param location Location of `got` given
 */
export declare const compareTwo: (expectedTypes: string | string[], receivedValue: unknown, location: string) => TypeCompareResult;
/**
 * Returns the type of `item` respecting `Array`, `null` and `undefined` unlike typeof.
 * @param item
 * @returns Type of item
 */
export declare const type: (item: unknown) => string;
/**
 * Breaks `array` into smaller chunks based on `chunkSize`
 * @param array Array to break up.
 * @param chunkSize Maximum size of array chunks.
 *
 * @returns Array containing array chunks.
 */
export declare const chunkArray: <T extends string | unknown[]>(array: T, chunkSize: number) => T[];
/**
 * stringifies and then parses a object to convert it to a JSON supported object.
 * @param obj Object to convert.
 * @example
 * const obj = {
 * 	a: 1,
 * 	b: [2, 7]
 * }
 * const a = objectify(obj)
 * const b = JSON.parse(JSON.stringify(obj))
 * console.log(a == b) -> true
 */
export declare const objectify: (obj: UnknownRecord) => UnknownRecord;
declare type AsyncFunction = (...args: unknown[]) => Promise<unknown>;
declare type ErrorHandler = (err: Error) => Promise<void>;
/**
 * Recursively runs `func` and handles errors with `errorHandler` until `func` successfully finishes.
 * @param func Function to execute
 * @param errorHandler Function to execute when a error occours
 * @returns Return value of `func` on success
 */
export declare const loopError: <F extends AsyncFunction>(func: F, errorHandler?: ErrorHandler) => ReturnType<F>;
/**
 * @param array
 * @returns string containing ranges of numbers.
 * @example
 * const range = toRange([1, 2, 3, 12, 6,7, 5, 27, 28, 29, 40, 41, 25, 42, 12])
 * // range = "1-3 & 5-7 & 12 & 25 & 27-29 & 40-42"
 */
export declare const toRange: (array: number[]) => string;
/**
 * Returns the `property` requested from `obj`
 * @param obj
 * @param property
 * @param delimiter
 * @example
 * const object = {
 * 	a: {
 * 		child: "Hello World"
 * 	}
 * }
 * const wantedProperty = "a.child"
 * console.log(deepGet(object, wantedProperty)) // -> "Hello World"
 */
export declare const deepGet: <T = unknown>(obj: UnknownRecord, property: string, delimiter?: string) => T | undefined;
/**
 * Replaces values in a given `templatestring` with contentKeys from a given `contentKeys` object.
 * @param contentKeys Object containing key value pairs of contentKeys to fill template string with
 * @param templatestring string containing templates to fill
 * @example
 * const contentKeys = {
 * 	"title": "This is a title",
 *  "info": {
 *   "desc": "This is some info!"
 *  }
 * }
 * const template = "Wow! {title}... Here is some info: {info.desc}"
 *
 * fillTemplate(contentKeys, template) // => Wow! This is a title... Here is some info: This is some info!"
 */
export declare const fillTemplate: (contentKeys: UnknownRecord, templatestring: string, parent?: string) => string;
declare type EnvDict = {
    [key: string]: string | EnvDict;
};
/**
 * Converts process.env variables into a object
 * @example process.env["some_subproperty"] = "hello"
 * returns { some: { subProperty: "hello" } }
 */
export declare const getEnv: () => EnvDict;
declare type RecursiveUpdateOptions = {
    setUndefined?: boolean;
    setDefined?: boolean;
};
/**
 * Recursively update properties of a object with another.
 * @param targetObject Object to update.
 * @param newObject Object with new values to write to `targetObject`.
 * @param options.setUndefined Defaults to `true` Set properties that are undefined on `targetObject`.
 * @param options.setDefined Defaults to `false`. Overwrite properties that are not undefined on `targetObject`.
 */
export declare const recursiveUpdate: (targetObject: UnknownRecord, newObject: UnknownRecord, options?: RecursiveUpdateOptions) => void;
/**
 * Set the types of a given `object` based on the types of an identical `types` object. Usful in conjunction with `getEnv` to convert a object only containing strings/objects to actual types.
 */
export declare const rebuildTypes: (object: UnknownRecord, types: UnknownRecord) => void;
/**
 * Fetch process.env[envName] or throw if its undefined
 */
export declare const envOrThrow: (envName: string) => string;
export {};
//# sourceMappingURL=object.d.ts.map